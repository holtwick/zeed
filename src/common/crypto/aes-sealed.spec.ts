import { beforeAll, describe, expect, it } from 'vitest'
import { deriveKeyPbkdf2 } from '../crypto'
import { toBase64 } from '../data/bin'
import { hxDecrypt, hxEncrypt } from './aes-sealed'

describe('aes Encryption and Decryption', () => {
  let key: CryptoKey

  beforeAll(async () => {
    key = await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      true,
      ['encrypt', 'decrypt'],
    )
  })

  it('should encrypt and decrypt data correctly', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData = await hxEncrypt(data, key)
    const decryptedData = await hxDecrypt(encryptedData, key)
    expect(new TextDecoder().decode(decryptedData)).toBe('Hello, World!')
  })

  it('should produce different ciphertexts for the same plaintext', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData1 = await hxEncrypt(data, key)
    const encryptedData2 = await hxEncrypt(data, key)
    expect(encryptedData1).not.toEqual(encryptedData2)
  })

  it('should fail to decrypt with a different key', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData = await hxEncrypt(data, key)
    const differentKey = await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      true,
      ['encrypt', 'decrypt'],
    )
    await expect(hxDecrypt(encryptedData, differentKey)).rejects.toThrow()
  })

  it('should decrypt a sample that was generated by Swift code', async () => {
    const key = await deriveKeyPbkdf2(new Uint8Array([1, 2, 3]), {
      salt: new Uint8Array([1, 2, 3]),
      iterations: 100000,
    })
    const dataFromKey = await crypto.subtle.exportKey('raw', key)
    expect(toBase64(dataFromKey)).toMatchInlineSnapshot(`"+EZYmOnuVat0rvokPjZxkwdGacOiFvR2oaukTeVa84M="`)

    const sample = new Uint8Array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
    const encryptedData = await hxEncrypt(sample, key)
    expect(toBase64(encryptedData)).toMatchInlineSnapshot(
      `"WbwhO/CaS3W4VxiIIG3Zs4WdEa08CzEFgaQLs0TrRDejZ/8G0yu0S1JIV+3bn79O7SeyCfI0"`,
    )
    // const encryptedData = fromBase64('br6sc+pnZaIXcV1fTygAs/UJlDZIIBY50i56MMGNampZTcSakt0=')
    // const decryptedData = await hxDecrypt(encryptedData, key)
    // expect(decryptedData).toMatchInlineSnapshot()
  })
})
