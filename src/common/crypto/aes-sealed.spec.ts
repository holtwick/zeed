import { beforeAll, describe, expect, it } from 'vitest'
import { hxDecrypt, hxEncrypt } from './aes-sealed'

describe('aes Encryption and Decryption', () => {
  let key: CryptoKey

  beforeAll(async () => {
    key = await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      true,
      ['encrypt', 'decrypt'],
    )
  })

  it('should encrypt and decrypt data correctly', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData = await hxEncrypt(data, key)
    const decryptedData = await hxDecrypt(encryptedData, key)
    expect(new TextDecoder().decode(decryptedData)).toBe('Hello, World!')
  })

  it('should produce different ciphertexts for the same plaintext', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData1 = await hxEncrypt(data, key)
    const encryptedData2 = await hxEncrypt(data, key)
    expect(encryptedData1).not.toEqual(encryptedData2)
  })

  it('should fail to decrypt with a different key', async () => {
    const data = new TextEncoder().encode('Hello, World!')
    const encryptedData = await hxEncrypt(data, key)
    const differentKey = await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      true,
      ['encrypt', 'decrypt'],
    )
    await expect(hxDecrypt(encryptedData, differentKey)).rejects.toThrow()
  })

  // it('should decrypt a sample that was generated by Swift code', async () => {
  //   const key = await deriveKeyPbkdf2CBC(new Uint8Array([1, 2, 3]), {
  //     salt: new Uint8Array([1, 2, 3]),
  //   })
  //   // expect(toBase64(key)).toMatchInlineSnapshot()
  //   const sample = new Uint8Array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
  //   const encryptedData = fromBase64('br6sc+pnZaIXcV1fTygAs/UJlDZIIBY50i56MMGNampZTcSakt0=')
  //   const decryptedData = await hxDecrypt(encryptedData, key)
  //   expect(decryptedData).toMatchInlineSnapshot()
  // })
})
